(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "react", "react-dom"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("react"), require("react-dom"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.react, global.reactDom);
    global.useInViewport = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports, _react, _reactDom) {
  "use strict";

  _exports.__esModule = true;
  _exports["default"] = void 0;

  // React hooks
  var useInViewport = function useInViewport(target, options, config, props) {
    if (config === void 0) {
      config = {
        disconnectOnLeave: false
      };
    }

    var onEnterViewport = props.onEnterViewport,
        onLeaveViewport = props.onLeaveViewport;

    var _useState = (0, _react.useState)(),
        forceUpdate = _useState[1];

    var observer = (0, _react.useRef)();
    var inViewportRef = (0, _react.useRef)(false);
    var intersected = (0, _react.useRef)(false);
    var enterCountRef = (0, _react.useRef)(0);
    var leaveCountRef = (0, _react.useRef)(0);

    function startObserver() {
      if (target.current && observer.current) {
        var node = (0, _reactDom.findDOMNode)(target.current);

        if (node) {
          observer.current.observe(node);
        }
      }
    }

    function stopObserver() {
      if (target.current && observer.current) {
        var node = (0, _reactDom.findDOMNode)(target.current);

        if (node) {
          observer.current.unobserve(node);
          observer.current.disconnect();
          observer.current = null;
        }
      }
    }

    function handleIntersection(entries) {
      var entry = entries[0] || {};
      var isIntersecting = entry.isIntersecting,
          intersectionRatio = entry.intersectionRatio;
      var isInViewport = typeof isIntersecting !== 'undefined' ? isIntersecting : intersectionRatio > 0; // enter

      if (!intersected.current && isInViewport) {
        intersected.current = true;
        onEnterViewport && onEnterViewport();
        enterCountRef.current += 1;
        inViewportRef.current = isInViewport;
        forceUpdate(isInViewport);
        return;
      } // leave


      if (intersected.current && !isInViewport) {
        intersected.current = false;
        onLeaveViewport && onLeaveViewport();

        if (config.disconnectOnLeave && observer.current) {
          // disconnect obsever on leave
          observer.current.disconnect();
        }

        leaveCountRef.current += 1;
        inViewportRef.current = isInViewport;
        forceUpdate(isInViewport);
      }
    }

    function initIntersectionObserver() {
      if (!observer.current) {
        // $FlowFixMe
        observer.current = new IntersectionObserver(handleIntersection, options);
      }
    }

    (0, _react.useEffect)(function () {
      // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
      initIntersectionObserver();
      startObserver();
      return function () {
        stopObserver();
      };
    }, [target, options, config, onEnterViewport, onLeaveViewport]);
    return {
      inViewport: inViewportRef.current,
      enterCount: enterCountRef.current,
      leaveCount: leaveCountRef.current
    };
  };

  var _default = useInViewport;
  _exports["default"] = _default;
});